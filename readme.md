# Cheat Code Commander: Your Ultimate Cheat Composition Tool

## Introduction

Welcome to Cheat Code Commander, the definitive tool for PC power-users to compose, combine, and customize cheat codes. This application is designed to read, write, and understand cheat code from multiple authors in a human-friendly format, allowing you to tailor your gaming experience like never before.

This guide will walk you through every aspect of the tool, from its core features and user interface to advanced techniques like code cave relocation.

## Getting Started: A Quick Guide

Here’s a simple workflow to get you started with Cheat Code Commander:

1.  **Open a Cheat File:**
    *   **Drag and Drop:** The easiest way is to drag your cheat file and drop it onto the left (Assembler) or center (Opcodes) panel.
    *   **Open File Button:** Click "Open ASM File" to load your cheat source code, or "Open Opcodes File" to load raw opcodes.
2.  **Write or Edit a Cheat:** In the assembler panel (left), write a new cheat or modify an existing one. As you type, the center panel will update with the raw opcodes.
3.  **Disassemble a Cheat:** Paste a raw cheat code into the center panel. The disassembler (right panel) will automatically show you the human-readable version.
4.  **Save Your Work:** Use the "Save ASM File", "Save Opcodes", or "Save Disassembly" buttons to save your work.
5.  **Auto-Load Last File:** Check the "Reload on Launch" checkbox to have Cheats Commander automatically open your most recent work on startup.

## Core Features

Cheat Code Commander is packed with features designed to make cheat development more intuitive and powerful:

-   **Unified Three-Panel Layout:** A clear and efficient workspace with dedicated panels for assembling, disassembling, and a shared opcode view.
-   **Live Assembly & Disassembly:** See your code transform in real-time as you write and edit.
-   **Powerful ARM64 Support:** Directly assemble and disassemble ARM64 instructions using the integrated Keystone and Capstone engines.
-   **Advanced ASM Editor:** A dedicated window for editing ARM64 assembly. Add or delete lines, define labels, and use standard Keystone data directives (e.g., `.word`, `.float`, `.double`).
-   **Code Cave Relocation:** A one-click solution to automatically move all your cheats to a safe memory location, preventing conflicts and crashes.
-   **Rich Cheat Syntax:** A human-readable syntax that supports a wide range of cheat types, including conditionals, loops, and register manipulation.
-   **Drag-and-Drop Support:** Easily open cheat files by dragging them into the application window.
-   **Context-Aware Menus:** Right-click menus provide quick access to common actions like editing ASM, managing code caves, and reordering cheats.

## The User Interface

The Cheat Code Commander interface is divided into three main panels to provide a clear and organized workflow:

-   **Left Panel (Assembler):** This is where you write and edit your cheats using the custom, human-readable syntax. The assembler provides real-time feedback, highlighting errors and showing the assembled opcodes in the center panel.
-   **Center Panel (Opcodes):** This shared, editable text area displays the raw hexadecimal opcodes generated by the assembler. You can also paste raw cheats here to have them disassembled in the right panel.
-   **Right Panel (Disassembler):** This panel shows the human-readable output of the disassembler. It converts raw opcodes from the center panel into a more understandable format, including ARM64 instructions where possible.

## The Assembler: Power and Precision

The assembler is the heart of Cheat Code Commander. It converts your human-readable cheat syntax into the raw hexadecimal codes that the Nintendo Switch can understand.

### Live Assembly

The assembler works in real-time. As you type in the left panel, the center panel instantly updates to show the assembled opcodes. If there are any syntax errors in your code, the assembler will highlight the problematic line to help you correct it.

### Assembler Syntax Reference

The assembler uses a custom syntax to define cheats. All cheats are placed under a title in `[CheatName]` format.

#### Static Memory Write

Writes a static value to a memory address. The assembler can also interpret the value as ARM64 assembly.

**Syntax:**

```
[<MemoryType>+R<Register>+<Address>] = <Value>
[<MemoryType>+R<Register>+<Address>] = <ARM64 Instruction(s)>
```

**Example:**

```
[Main+R0+0x123456] = 0x1E200001  # mov x1, #1
[Main+R0+0x12345A] = nop; nop
[Main+R0+0x12345E] = .word 0xDEADBEEF
[Main+R0+0x123462] = .float 3.14
```

#### Pointer Auto-Increment (Store with Post-Increment)

The assembler supports an auto-increment feature for memory writes where the source register used as a pointer is incremented after the write operation. This is useful for writing sequential data in a loop.

**Assembler Syntax:**

To use this feature, append an exclamation mark (`!`) to the closing bracket of the address.

```
[R<d>]! = <Value>
[R<d>]! = R<s>
```

-   **`[R<d>]!`**: This syntax writes the value (either a static `<Value>` or the value from a source register `R<s>`) to the address pointed to by `R<d>`. After the write, the register `R<d>` is incremented by the width of the operation (e.g., 4 bytes for a 32-bit value, 8 bytes for a 64-bit value).

**Example:**

```
# This will write the value of R1 to the address in R0,
# and then increment R0 by the write width.
[R0]! = R1
```

**Disassembly Note:**

Please note that while the assembler uses the `[R<n>]!` syntax, the disassembler may represent this post-increment operation differently, for example using `R<n>+` notation. This is a known inconsistency in representation between the two components.

#### Conditional Blocks

Executes cheats only if a condition is met. This can be based on a value in memory or by comparing two registers. You can explicitly specify the bit-width for conditional operations using the `W={bit_width}` parameter for greater control.

**Syntax:**

```
if [<MemoryType>+<Address>] <Condition> <Value> [W=<BitWidth>]
if <Register> <Condition> <Value>
if <Register> <Condition> <Register>
... cheat codes ...
else
... cheat codes ...
endif
```

**Example:**

```
# Standard conditional
if [Main+0xABCDEF0] == 1
  [Main+R0+0x123456] = 0xDEADBEEF
else
  [Main+R0+0x123456] = 0
endif

# Register conditional
if R1 > 100
  R2 = 1
endif
```

#### Keypress Conditional

Executes cheats only when a specific button or combination of buttons is pressed or held.

**Syntax:**

```
if keyheld <Keys>
if keydown <Keys>
... cheat codes ...
endif
```

The `<Keys>` can be a hexadecimal `KeyMask` or a human-readable string (e.g., `L + R`).

**Example:**

```
# Executes every frame the L and R buttons are held
if keyheld L + R
  [Main+R0+0x123456] = 0xDEADBEEF
endif

# Executes once when the A button is first pressed
if keydown A
  R1 = R1 + 1
endif
```

**Supported Key Names:**

The assembler supports a wide range of key names, including `A`, `B`, `X`, `Y`, `L`, `R`, `ZL`, `ZR`, `LStick`, `RStick`, `Plus`, `Minus`, `DUp`, `DDown`, `DLeft`, `DRight`, and more. They are case-insensitive and can be combined with `+`.

#### Loops

Repeats a block of cheats a specific number of times.

**Syntax:**

```
loop start <Register> = <Count>
... cheat codes ...
loop stop <Register>
```

**Example:**

```
# Write 0 to 10 memory locations
R1 = 0
loop start R2 = 10
  [R0]! = R1 # The '!' increments R0 by the write width (default 4).
loop stop R2
```

#### Register Manipulation

Load values into registers, perform arithmetic, and store them back to memory.

**Syntax:**

- `R<d> = <Value>`
- `R<d> = [Address]`
- `[Address] = R<s>`
- `R<d> = R<s> <Op> R<t>`
- `R<d> = R<s> <Op> <Value>`

**Full Operator List:**

-   **Integer:** `+`, `-`, `*`, `<<` (left shift), `>>` (right shift), `&` (and), `|` (or), `^` (xor), `!` (not), `~` (neg)
-   **Floating Point:** `+f`, `-f`, `*f`, `/f`

### Atmosphere Cheat Engine Reference

The cheat syntax is based on the Atmosphere cheat engine. For a more detailed explanation of the underlying cheat format and capabilities, please refer to the official Atmosphere documentation:

[Atmosphere Cheats Documentation](https://github.com/Atmosphere-NX/Atmosphere/blob/master/docs/features/cheats.md)
## The Disassembler: Understanding the Code

The disassembler is your window into the inner workings of a cheat. It takes raw hexadecimal opcodes and converts them into a human-readable format.

### Live Disassembly

The disassembler works in real-time. Paste any raw cheat code into the center panel, and the right panel will instantly show you the disassembled output. This is incredibly useful for understanding what a cheat does, debugging it, or modifying it for your own purposes.

### Smart Disassembly

The disassembler uses the Capstone engine to disassemble memory write values back into ARM64 instructions where possible. This "smart check" helps you to identify and understand the assembly code that a cheat is writing into memory.

## Advanced Techniques

Cheat Code Commander includes several advanced features to streamline your workflow and unlock new possibilities.

### The ASM Editor

The ASM Editor provides a focused environment for writing and editing ARM64 assembly code. You can:

-   **Add and Delete Lines:** Freely modify your assembly code.
-   **Define Labels:** Use labels to create readable and maintainable code.
-   **Use Data Directives:** Define data values directly in your assembly using standard Keystone directives like `.word`, `.float`, and `.double`.

### Cut and Paste Cheats

To simplify cheat reordering, you can use the **"Cut Cheat"** and **"Paste Cheat"** options in the context menu. This allows you to easily move entire cheat blocks within the assembler input.

### Consolidating Cheats from Opcodes

A powerful workflow for managing cheats from multiple sources is to convert them all into the assembler format. This allows you to edit, manage, and relocate them as a single, unified cheat file.

1.  **Combine Opcodes:** Copy the raw opcodes from all your different cheat files and paste them together into the center **Opcodes** panel.
2.  **Disassemble:** The tool will automatically disassemble the combined opcodes and display the human-readable result in the right **Disassembler** panel.
3.  **Copy to Assembler:** Copy the entire output from the **Disassembler** panel and paste it into the left **Assembler** panel.

Once completed, you can edit all of your cheats in one place and use the **“Relocate All”** tool to ensure they work together without conflicts.

### New Features in 1.1.0

- **Scan ASM for Address** This tool helps you prepare for the "Relocate All" function by mapping all memory addresses modified by your cheats. This allows you to identify the starting point of the code cave used by the cheat's author, which is essential for a successful relocation.
  - **Important Note:** This feature is most effective when the original author built the code cave from the top down (from a low address to a high one). If the code was built from the bottom up, a manual search for the true starting address may still be necessary.
- **Set Free Code Start from Address Map:** For added ease, you can right-click on your choice to set the "Free Code Start" address.
- **Recreate Cheat Source from Opcodes:** A new right-click context menu option in the disassembler (right panel) called **"Copy to left panel"** allows you to recreate an editable cheat source from raw opcodes. This is the primary method for modifying cheat files when you do not have the original source code.

### How These Features Improve Your Workflow:
- **Quick start to Relocations:** The Address Usage Mapper save you time in finding free code space start.
- **Source Code Recreation:** Making coping from disassembler quicker when you don't have any source for assembler yet and want to copy everything.

## Code Cave and Relocation Workflow

Using a "code cave" is the most robust method for applying complex cheats. It involves finding unused memory space, placing your custom code there, and then diverting the game's execution to your code and back again. This section explains the core concepts and the workflow for using Cheat Code Commander's powerful relocation tools.

### Understanding the Core Concepts

Before you begin, it's crucial to understand these concepts:

#### Free Code Space

Custom cheat code can only be placed within a **code segment** of the game's memory. These segments are allocated in 4 kilobyte (4KB) blocks. Since a game's actual code rarely fills a block perfectly, there is usually unused space at the end of the segment. This space is filled with `00` bytes and is referred to as **Free Code Space**.

To find it, you must use an external tool like a hex editor to look at the end of the game's code segment and move backwards until you find non-zero code. The size of this space is determined by the distance between the end of the legitimate code and the 4KB boundary. As a rule of thumb, the last four hex digits of the address at the very end of the free code space block is often `FFF`. The lower the starting address of the free space, the more room you have for your cheats.

#### Code Caves & Hooks

A **Code Cave** is a specific location *within* the Free Code Space that you choose to write your custom cheat logic (your "hack").

A **Hook** is the mechanism that activates your code cave. It works by replacing a piece of the original game's code with a **branch instruction**. This branch redirects the game's execution to your code cave. After your custom instructions run, you must add a final branch instruction to return to the original game code, allowing the game to continue as normal.

**Hazard Warning:** Different cheat authors may build their code caves in different ways. Some start from the top of the free space and build down, while others start from the bottom and build up. When you mix cheats from multiple authors, their code caves can overwrite each other. This is a primary cause of game crashes, making careful management of your code cave space critical. Cheat Code Commander's **“Relocate All”** tool is designed to solve this exact problem.

### Workflow: Finding and Using a Code Cave

Here is the recommended workflow for using code caves in Cheat Code Commander:

#### Step 1: Find the Free Code Space

Using a hex editor or memory viewer, inspect the game's memory dump to find a suitable region of Free Code Space as described above. Identify the starting address of the large block of `00` bytes you wish to use.

#### Step 2: Set the Code Cave Start Address

Once you've found a suitable starting address, you need to tell Cheat Code Commander where it is.

1.  In the assembler window, manually enter the address you found into the **“Free Code Start”** text field.
2.  Alternatively, you can find and set the start address from an existing cheat file:
    *   First, ensure the cheats are loaded into the **Assembler** panel (left), as this is the only panel processed by the relocation tools. You can use the "Consolidating Cheats from Opcodes" workflow described in the previous section to do this.
    *   In the **Assembler** panel, look for the hooks. These are typically `b` (branch) instructions that jump from a low address (the game's original code) to a high address (the code cave).
    *   Examine all such branches and find the lowest of these high addresses. This is the starting point of the existing code caves.
    *   In the **Assembler** panel, right-click the line that contains this lowest address and select **“Set as Free Code Start”** from the context menu.

#### Step 3: Relocate Your Cheats

With the **“Free Code Start”** location set, click the **“Relocate All”** button.
The tool will automatically rewrite all your cheats to reside sequentially in the specified code cave, preventing collisions and ensuring that your cheats work together seamlessly.

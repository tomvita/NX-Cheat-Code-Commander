# Cheat Code Commander: Your Ultimate Cheat Composition Tool

## Introduction

Welcome to Cheat Code Commander, the definitive tool for PC power-users to compose, combine, and customize cheat codes. This application is designed to read, write, and understand cheat code from multiple authors in a human-friendly format, allowing you to tailor your gaming experience like never before.

This guide will walk you through every aspect of the tool, from its core features and user interface to advanced techniques like code cave relocation.

## Getting Started: A Quick Guide

Here’s a simple workflow to get you started with Cheat Code Commander:

1.  **Open a Cheat File:**
    *   **Drag and Drop:** The easiest way is to drag your cheat file and drop it onto the left (Assembler) or center (Opcodes) panel.
    *   **Open File Button:** Click "Open ASM File" to load your cheat source code, or "Open Opcodes File" to load raw opcodes.
2.  **Write or Edit a Cheat:** In the assembler panel (left), write a new cheat or modify an existing one. As you type, the center panel will update with the raw opcodes.
3.  **Disassemble a Cheat:** Paste a raw cheat code into the center panel. The disassembler (right panel) will automatically show you the human-readable version.
4.  **Save Your Work:** Use the "Save ASM File", "Save Opcodes", or "Save Disassembly" buttons to save your work.
5.  **Auto-Load Last File:** Check the "Reload on Launch" checkbox to have Cheats Commander automatically open your most recent work on startup.

## Core Features

Cheat Code Commander is packed with features designed to make cheat development more intuitive and powerful:

-   **Unified Layout:** A clear and efficient workspace with dedicated panels for assembling, disassembling, and viewing opcodes, with an optional 4-panel mode for advanced comparison.
-   **Live Assembly & Disassembly:** See your code transform in real-time as you write and edit.
-   **Powerful ARM64 Support:** Directly assemble and disassemble ARM64 instructions using the integrated Keystone and Capstone engines.
-   **Advanced ASM Editor:** A dedicated window for editing ARM64 assembly. Add or delete lines, define labels, and use standard Keystone data directives (e.g., `.word`, `.float`, `.double`).
-   **Code Cave Relocation:** A one-click solution to automatically move all your cheats to a safe memory location, preventing conflicts and crashes.
-   **Rich Cheat Syntax:** A human-readable syntax that supports a wide range of cheat types, including conditionals, loops, and register manipulation.
-   **Drag-and-Drop Support:** Easily open cheat files by dragging them into the application window.
-   **Context-Aware Menus:** Right-click menus provide quick access to common actions like editing ASM, managing code caves, and reordering cheats.
-   **Customizable View:** Adjust panel widths with "Fit" buttons and toggle word wrap to customize your layout.
-   **Synchronized Navigation:** Click on any cheat name to instantly sync all panels to the same location, with highlighting for easy identification.

## The User Interface

The Cheat Code Commander interface is designed for a clear and organized workflow.

-   **Left Panel (Assembler):** This is where you write and edit your cheats using the custom, human-readable syntax. The assembler provides real-time feedback, highlighting errors and showing the assembled opcodes in the center panel.
-   **Center Panel (Opcodes):** This shared, editable text area displays the raw hexadecimal opcodes generated by the assembler. You can also paste raw cheats here to have them disassembled in the right panel.
-   **Right Panel (Disassembler):** This panel shows the human-readable output of the disassembler. It converts raw opcodes from the center panel into a more understandable format, including ARM64 instructions where possible.

### Additional UI Controls

*   **Fit 1 & Fit 2 Buttons:**
    *   **Fit 1:** Adjusts the width of each panel to fit its content, including cheat titles. This is useful for getting a quick overview of all your cheats.
    *   **Fit 2:** Similar to Fit 1, but it ignores cheat titles when calculating the optimal width. This provides a more compact view that focuses on the code.
*   **Word Wrap Checkbox:**
    *   A new "Word Wrap" checkbox has been added to the main window. When enabled, text in all panels will wrap to fit the panel width. When disabled, text will not wrap, and a horizontal scrollbar will appear if necessary. This setting is saved and will be restored on the next launch.

### 4-Panel Mode for Enhanced Comparison

For more complex analysis, a "4-panel mode" can be enabled from the main toolbar. This provides a powerful environment for comparing two different sets of opcodes side-by-side.

*   **Layout:** When enabled, the application displays two opcode panels in the center.
*   **Independent Updates:** The center-left panel updates with your live assembly changes, while the center-right panel can be used to load a separate opcode file for reference. Both panels feed into the disassembler.
*   **Copy to Right:** A context menu option allows you to quickly copy opcodes from the left panel to the right, setting a new baseline for comparison.

### Synchronized Scrolling and Navigation

To improve navigation and streamline your workflow, synchronized scrolling and click-to-sync is enabled across all text panels.

*   **Click to Sync:** A left-click on a cheat's title in any of the main text panels (Assembler, Opcode, or Disassembly) or the logs will now automatically scroll all other panels to display the corresponding cheat. If you click within the body of a cheat and its title is not currently visible, the panel will automatically scroll to bring the title into view before synchronizing. This ensures you never lose context.
*   **Highlighting:** The clicked cheat name will be highlighted in yellow for two seconds, making it easy to spot.

## The Assembler: Power and Precision

The assembler is the heart of Cheat Code Commander. It converts your human-readable cheat syntax into the raw hexadecimal codes that the Nintendo Switch can understand.

### Live Assembly

The assembler works in real-time. As you type in the left panel, the center panel instantly updates to show the assembled opcodes. If there are any syntax errors in your code, the assembler will highlight the problematic line to help you correct it.

### Assembler Syntax Reference

The assembler uses a custom syntax to define cheats. All cheats are placed under a title in `[CheatName]` format.

#### Static Memory Write

Writes a static value to a memory address. The assembler can also interpret the value as ARM64 assembly.

**Syntax:**

```
[<MemoryType>+R<Register>+<Address>] = <Value>
[<MemoryType>+R<Register>+<Address>] = <ARM64 Instruction(s)>
```

**Example:**

```
[Main+R0+0x123456] = 0x1E200001  # mov x1, #1
[Main+R0+0x12345A] = nop; nop
[Main+R0+0x12345E] = .word 0xDEADBEEF
[Main+R0+0x123462] = .float 3.14
```

#### Pointer Auto-Increment (Store with Post-Increment)

The assembler supports an auto-increment feature for memory writes where the source register used as a pointer is incremented after the write operation. This is useful for writing sequential data in a loop.

**Assembler Syntax:**

To use this feature, append an exclamation mark (`!`) to the closing bracket of the address.

```
[R<d>]! = <Value>
[R<d>]! = R<s>
```

-   **`[R<d>]!`**: This syntax writes the value (either a static `<Value>` or the value from a source register `R<s>`) to the address pointed to by `R<d>`. After the write, the register `R<d>` is incremented by the width of the operation (e.g., 4 bytes for a 32-bit value, 8 bytes for a 64-bit value).

**Disassembly Note:** Please note that while the assembler uses the `[R<n>]!` syntax, the disassembler may represent this post-increment operation differently, for example using `R<n>+` notation.

#### Conditional Blocks

Executes cheats only if a condition is met. You can explicitly specify the bit-width for conditional operations using the `W={bit_width}` parameter for greater control.

**Syntax:**

```
if [<MemoryType>+<Address>] <Condition> <Value> [W=<BitWidth>]
if <Register> <Condition> <Value> or <Register>
... cheat codes ...
else
... cheat codes ...
endif
```

#### Keypress Conditional

Executes cheats only when a specific button or combination of buttons is pressed or held.

**Syntax:**

```
if keyheld <Keys>
if keydown <Keys>
... cheat codes ...
endif
```

The `<Keys>` can be a hexadecimal `KeyMask` or a human-readable string (e.g., `L + R`). The assembler supports a wide range of key names, which are case-insensitive and can be combined with `+`.

#### Loops

Repeats a block of cheats a specific number of times.

**Syntax:**

```
loop start <Register> = <Count>
... cheat codes ...
loop stop <Register>
```

#### Register Manipulation

Load values into registers, perform arithmetic, and store them back to memory.

**Syntax:**

- `R<d> = <Value>`
- `R<d> = [Address]`
- `[Address] = R<s>`
- `R<d> = R<s> <Op> R<t>` or `R<d> = R<s> <Op> <Value>`

**Full Operator List:**

-   **Integer:** `+`, `-`, `*`, `<<`, `>>`, `&`, `|`, `^`, `!`, `~`
-   **Floating Point:** `+f`, `-f`, `*f`, `/f`

### Atmosphere Cheat Engine Reference

The cheat syntax is based on the Atmosphere cheat engine. For a more detailed explanation of the underlying cheat format and capabilities, please refer to the [official Atmosphere documentation](https://github.com/Atmosphere-NX/Atmosphere/blob/master/docs/features/cheats.md).

## The Disassembler: Understanding the Code

The disassembler is your window into the inner workings of a cheat. It takes raw hexadecimal opcodes and converts them into a human-readable format.

### Live Disassembly

The disassembler works in real-time. Paste any raw cheat code into the center panel, and the right panel will instantly show you the disassembled output. This is incredibly useful for understanding, debugging, or modifying a cheat.

### Smart Disassembly

The disassembler uses the Capstone engine to disassemble memory write values back into ARM64 instructions where possible. This "smart check" helps you to identify and understand the assembly code that a cheat is writing into memory.

## Advanced Techniques

Cheat Code Commander includes several advanced features to streamline your workflow and unlock new possibilities.

### The ASM Editor

The ASM Editor provides a focused environment for writing and editing ARM64 assembly code. You can add/delete lines, define labels, and use standard Keystone data directives (`.word`, `.float`, etc.).

### Cut and Paste Cheats

To simplify cheat reordering, you can use the **"Cut Cheat"** and **"Paste Cheat"** options in the context menu to easily move entire cheat blocks within the assembler input.

### Recreating and Consolidating Cheats

A powerful workflow for managing cheats from multiple sources is to convert them all into the assembler format. This allows you to edit, manage, and relocate them as a single, unified cheat file.

1.  **Combine Opcodes:** Copy the raw opcodes from all your different cheat files and paste them together into the center **Opcodes** panel.
2.  **Disassemble:** The tool will automatically disassemble the combined opcodes in the right **Disassembler** panel.
3.  **Copy to Assembler:** Right-click anywhere in the disassembler panel and select **"Copy to left panel"**. This will recreate the entire editable cheat source in the assembler, which is the primary method for modifying cheats when you don't have the original source code.

Once completed, you can edit all of your cheats in one place and use the **“Relocate All”** tool to ensure they work together without conflicts.

## Code Cave and Relocation Workflow

Using a "code cave" is the most robust method for applying complex cheats. It involves finding unused memory, placing your custom code there, and then hooking the game's execution to your code.

### Understanding the Core Concepts

-   **Free Code Space:** Unused memory within a game's 4KB code segments. This is where your custom code will live.
-   **Code Cave:** A specific location *within* the Free Code Space where you write your custom cheat logic.
-   **Hook:** A branch instruction that replaces original game code to redirect execution to your code cave. After your code runs, a final branch must return to the original code.

**Hazard Warning:** Different cheat authors may build code caves differently (top-down vs. bottom-up). Mixing them can cause crashes. The **“Relocate All”** tool is designed to solve this problem by organizing all cheats into one contiguous block.

### Workflow: Finding and Using a Code Cave

#### Step 1: Find the Free Code Space

Using a hex editor or memory viewer, inspect the game's memory dump to find a suitable region of `00` bytes. Identify the starting address of this block.

#### Step 2: Set the Code Cave Start Address

You need to tell Cheat Code Commander where the free space begins.

1.  **Manual Entry:** Enter the address you found into the **“Free Code Start”** text field.
2.  **Automated Scanning:** To find the start address from an existing cheat file, first load it into the assembler.
    *   Right-click in the assembler and select **"Scan ASM for Address"**. This tool maps all memory addresses modified by the cheats, helping you identify the start of the author's code cave.
    *   In the address map that appears, you can right-click on your choice and select **"Set Free Code Start from Address Map"**.
    *   **Note:** This is most effective when the original author built the code cave from top-down. If built bottom-up, a manual search may still be necessary.

#### Step 3: Relocate Your Cheats

With the **“Free Code Start”** location set, click the **“Relocate All”** button. The tool will automatically rewrite all your cheats to reside sequentially in the specified code cave, preventing collisions and ensuring that your cheats work together seamlessly.

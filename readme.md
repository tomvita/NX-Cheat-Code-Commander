# Cheats Commander: The All-in-One Cheat Tool

## Introduction

Welcome to Cheats Commander, the ultimate tool for creating, editing, and understanding cheat codes for the Nintendo Switch. This application combines the power of a cheat assembler and disassembler into a single, streamlined interface. Whether you're a seasoned cheat developer or just getting started, Cheats Commander provides the features and flexibility you need to master the art of game modification.

This guide will walk you through every aspect of the tool, from its core features and user interface to advanced techniques like code cave relocation.

## Core Features

Cheats Commander is packed with features designed to make cheat development more intuitive and powerful:

-   **Unified Three-Panel Layout:** A clear and efficient workspace with dedicated panels for assembling, disassembling, and a shared opcode view.
-   **Live Assembly & Disassembly:** See your code transform in real-time as you write and edit.
-   **Powerful ARM64 Support:** Directly assemble and disassemble ARM64 instructions using the integrated Keystone and Capstone engines.
-   **Advanced ASM Editor:** A dedicated window for editing and testing ARM64 assembly, with real-time feedback.
-   **Code Cave Relocation:** A one-click solution to automatically move all your cheats to a safe memory location, preventing conflicts and crashes.
-   **Rich Cheat Syntax:** A human-readable syntax that supports a wide range of cheat types, including conditionals, loops, and register manipulation.
-   **Drag-and-Drop Support:** Easily open cheat files by dragging them into the application window.
-   **Context-Aware Menus:** Right-click menus provide quick access to common actions like editing ASM, managing code caves, and reordering cheats.

## The User Interface

The Cheats Commander interface is divided into three main panels to provide a clear and organized workflow:

-   **Left Panel (Assembler):** This is where you write and edit your cheats using the custom, human-readable syntax. The assembler provides real-time feedback, highlighting errors and showing the assembled opcodes in the center panel.
-   **Center Panel (Opcodes):** This shared, editable text area displays the raw hexadecimal opcodes generated by the assembler. You can also paste raw cheats here to have them disassembled in the right panel.
-   **Right Panel (Disassembler):** This panel shows the human-readable output of the disassembler. It converts raw opcodes from the center panel into a more understandable format, including ARM64 instructions where possible.

## Getting Started: A Basic Workflow

Here’s a simple workflow to get you started with Cheats Commander:

1.  **Open a Cheat File:** Drag and drop a cheat `.txt` file into the assembler (left) or disassembler (right) panel.
2.  **Write or Edit a Cheat:** In the assembler panel, write a new cheat or modify an existing one. As you type, the center panel will update with the raw opcodes.
3.  **Disassemble a Cheat:** Paste a raw cheat code into the center panel. The disassembler (right panel) will automatically show you the human-readable version.
4.  **Save Your Work:** Use the "Save" buttons to save your assembled cheats or the disassembled output.

## The Assembler: Power and Precision

The assembler is the heart of Cheats Commander. It converts your human-readable cheat syntax into the raw hexadecimal codes that the Nintendo Switch can understand.

### Live Assembly

The assembler works in real-time. As you type in the left panel, the center panel instantly updates to show the assembled opcodes. If there are any syntax errors in your code, the assembler will highlight the problematic line, helping you to debug your cheats quickly.

### Assembler Syntax Reference

The assembler uses a custom syntax to define cheats. All cheats are placed under a title in `[CheatName]` format.

#### Static Memory Write

Writes a static value to a memory address. The assembler can also interpret the value as ARM64 assembly.

**Syntax:**

```
[<MemoryType>+R<Register>+<Address>] = <Value>
[<MemoryType>+R<Register>+<Address>] = <ARM64 Instruction(s)>
```

**Example:**

```
[Main+R0+0x123456] = 0x1E200001  # mov x1, #1
[Main+R0+0x12345A] = nop; nop
[Main+R0+0x12345E] = .word 0xDEADBEEF
[Main+R0+0x123462] = .float 3.14
```

#### Pointer Auto-Increment for Register-Based Static Writes

When writing a static value to a memory address pointed to by a register (e.g., `[R10]`), the assembler provides flexible ways to auto-increment the pointer after the write operation.

-   **`R<n>+`**: Appending a `+` to the register in the address part increments that register by the operation's bit-width.
-   **`R<n> += <value>`**: An explicit increment value can be specified. The increment is only applied if `<value>` matches the operation's bit-width.

**Example:**

```
# Using R+ to increment R10 by 8
[R10] = 0x1000000001000110 W=8 R10+

# Using R += value to increment R10 by 4
[R10] = 0x1234 W=4 R10 += 4
```

#### Conditional Blocks

Executes cheats only if a condition is met. This can be based on a value in memory or by comparing two registers. You can explicitly specify the bit-width for conditional operations using the `W={bit_width}` parameter for greater control.

**Syntax:**

```
if [<MemoryType>+<Address>] <Condition> <Value> [W=<BitWidth>]
if <Register> <Condition> <Value>
if <Register> <Condition> <Register>
... cheat codes ...
else
... cheat codes ...
endif
```

**Example:**

```
# Standard conditional
if [Main+0xABCDEF0] == 1
  [Main+R0+0x123456] = 0xDEADBEEF
else
  [Main+R0+0x123456] = 0
endif

# Register conditional
if R1 > 100
  R2 = 1
endif
```

#### Keypress Conditional

Executes cheats only when a specific button or combination of buttons is pressed or held.

**Syntax:**

```
if keyheld <Keys>
if keydown <Keys>
... cheat codes ...
endif
```

The `<Keys>` can be a hexadecimal `KeyMask` or a human-readable string (e.g., `L + R`).

**Example:**

```
# Executes every frame the L and R buttons are held
if keyheld L + R
  [Main+R0+0x123456] = 0xDEADBEEF
endif

# Executes once when the A button is first pressed
if keydown A
  R1 = R1 + 1
endif
```

**Supported Key Names:**

The assembler supports a wide range of key names, including `A`, `B`, `X`, `Y`, `L`, `R`, `ZL`, `ZR`, `LStick`, `RStick`, `Plus`, `Minus`, `DUp`, `DDown`, `DLeft`, `DRight`, and more. They are case-insensitive and can be combined with `+`.

#### Loops

Repeats a block of cheats a specific number of times.

**Syntax:**

```
loop start <Register> = <Count>
... cheat codes ...
loop stop <Register>
```

**Example:**

```
# Write 0 to 10 memory locations
R1 = 0
loop start R2 = 10
  [R0]! = R1 # The '!' increments R0 by the write width (default 4).
loop stop R2
```

#### Register Manipulation

Load values into registers, perform arithmetic, and store them back to memory.

**Syntax:**

- `R<d> = <Value>`
- `R<d> = [Address]`
- `[Address] = R<s>`
- `R<d> = R<s> <Op> R<t>`
- `R<d> = R<s> <Op> <Value>`

**Full Operator List:**

-   **Integer:** `+`, `-`, `*`, `<<` (left shift), `>>` (right shift), `&` (and), `|` (or), `^` (xor), `!` (not), `~` (neg)
-   **Floating Point:** `+f`, `-f`, `*f`, `/f`

## The Disassembler: Understanding the Code

The disassembler is your window into the inner workings of a cheat. It takes raw hexadecimal opcodes and converts them into a human-readable format.

### Live Disassembly

The disassembler works in real-time. Paste any raw cheat code into the center panel, and the right panel will instantly show you the disassembled output. This is incredibly useful for understanding what a cheat does, debugging it, or modifying it for your own purposes.

### Smart Disassembly

The disassembler uses the Capstone engine to disassemble memory write values back into ARM64 instructions where possible. This "smart check" helps you to identify and understand the assembly code that a cheat is writing into memory.

## Advanced Techniques

Cheats Commander includes several advanced features to streamline your workflow and unlock new possibilities.

### The ASM Editor

The ASM Editor is a powerful tool for working with ARM64 assembly. To use it:

1.  **Select a cheat line** containing ARM64 assembly in the assembler input panel.
2.  **Right-click** and choose **"Edit ASM"** from the context menu.
3.  An **ASM Editor** window will appear, pre-filled with the disassembled instructions.
4.  **Modify the assembly code** as needed.
5.  Click the **"Assemble"** button to apply the changes. The tool will update the original cheat line with the newly assembled code.

### Cut and Paste Cheats

To simplify cheat reordering, you can use the **"Cut Cheat"** and **"Paste Cheat"** options in the context menu. This allows you to easily move entire cheat blocks within the assembler input.

## Code Cave and Relocation Workflow

A "code cave" is a region of unused memory within a game. Using a code cave for your cheats is the best way to prevent them from conflicting with the game's code or with each other. Cheats Commander provides a powerful workflow for finding and using code caves.

### Step 1: What is a Code Cave?

A code cave is a region of unused memory within a game's executable or memory dump. These areas are typically filled with zeroes or placeholder instructions (`udf`). They provide a safe space to insert custom code without overwriting important game logic.

### Step 2: How to Identify a Code Cave

You can use the **Disassembler** to find potential code caves:

1.  Open a memory dump in the disassembler.
2.  Look for large, contiguous blocks of `udf #0` or `00000000` opcodes. These patterns indicate unused space.

### Step 3: Set the Code Cave Location

Once you've found a suitable code cave, you need to tell Cheats Commander where it is.

1.  In the disassembler's output, right-click the line containing the **starting address** of the code cave.
2.  Select **“Set as Free Code Start”** from the context menu.
3.  This action will automatically populate the **“Free Code Start”** field in the assembler window.

### Step 4: Relocate Your Cheats

With the code cave location set, you can now move all your cheats into it with a single click.

1.  Switch to the **Assembler** window.
2.  Click the **“Relocate All”** button.

The tool will automatically handle the rest, safely rewriting all your cheats to reside in the specified code cave. This prevents collisions and ensures that your cheats work together seamlessly.